import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from sklearn.linear_model import LinearRegression, RANSACRegressor
from sklearn.preprocessing import PolynomialFeatures
from itertools import combinations
import warnings
warnings.filterwarnings('ignore')

st.set_page_config(page_title="T·ªëi ∆Øu Gi√° B√°n Cafe & Ph√¢n T√≠ch ƒê·ªëi Th·ªß", layout="wide")
st.title("‚òï ·ª®ng d·ª•ng T·ªëi ∆Øu & Ph√¢n T√≠ch Gi√° B√°n Cafe Shop (C·∫°nh Tranh)")

# Sidebar: upload d·ªØ li·ªáu
st.sidebar.header("üöÄ Upload d·ªØ li·ªáu")
u_meta  = st.sidebar.file_uploader("Sell Meta Data (CSV)", type="csv")
u_trans = st.sidebar.file_uploader("Transaction Store (CSV)", type="csv")
u_date  = st.sidebar.file_uploader("Date Info (CSV)", type="csv")

if not (u_meta and u_trans and u_date):
    st.sidebar.info("Vui l√≤ng upload c·∫£ 3 file ƒë·ªÉ b·∫Øt ƒë·∫ßu!")
    st.info("Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi ·ª©ng d·ª•ng ph√¢n t√≠ch gi√° b√°n c√† ph√™! Vui l√≤ng t·∫£i l√™n 3 t·ªáp CSV ƒë·ªÉ b·∫Øt ƒë·∫ßu ph√¢n t√≠ch:")
    st.markdown("""
    - **Sell Meta Data**: Ch·ª©a th√¥ng tin v·ªÅ s·∫£n ph·∫©m v√† danh m·ª•c
    - **Transaction Store**: Ch·ª©a d·ªØ li·ªáu giao d·ªãch b√°n h√†ng
    - **Date Info**: Ch·ª©a th√¥ng tin v·ªÅ ng√†y (l·ªÖ, cu·ªëi tu·∫ßn, m√πa v·ª•)
    """)
    st.stop()

try:
    # Gi·∫£ s·ª≠ b·∫°n ƒë√£ t·∫£i c√°c file t·ª´ sidebar
    sell_meta = pd.read_csv(u_meta)
    transaction = pd.read_csv(u_trans)
    date_info = pd.read_csv(u_date)

    # Chu·∫©n h√≥a t√™n c·ªôt
    sell_meta.columns = sell_meta.columns.str.strip()
    transaction.columns = transaction.columns.str.strip()
    date_info.columns = date_info.columns.str.strip()

    # Convert CALENDAR_DATE sang ƒë·ªãnh d·∫°ng datetime (n·∫øu ch∆∞a)
    transaction['CALENDAR_DATE'] = pd.to_datetime(transaction['CALENDAR_DATE'], errors='coerce')
    date_info['CALENDAR_DATE'] = pd.to_datetime(date_info['CALENDAR_DATE'], errors='coerce')

    # Merge d·ªØ li·ªáu transaction v√† sell_meta
    merged = pd.merge(transaction, sell_meta, on=["SELL_ID", "SELL_CATEGORY"], how="left")

    # Merge d·ªØ li·ªáu merged v·ªõi date_info d·ª±a tr√™n CALENDAR_DATE
    merged = pd.merge(merged, date_info, on="CALENDAR_DATE", how="left")

    # Ki·ªÉm tra k·∫øt qu·∫£ merge
    st.write("K·∫øt qu·∫£ sau khi merge:")
    st.dataframe(merged.head())
    
    # Hi·ªÉn th·ªã th·ªëng k√™ c∆° b·∫£n
    st.write("Th·ªëng k√™ c∆° b·∫£n c·ªßa d·ªØ li·ªáu:")
    st.write(f"S·ªë l∆∞·ª£ng giao d·ªãch: {len(merged):,}")
    st.write(f"S·ªë l∆∞·ª£ng s·∫£n ph·∫©m: {merged['ITEM_NAME'].nunique():,}")
    st.write(f"Kho·∫£ng th·ªùi gian: {merged['CALENDAR_DATE'].min().date()} ƒë·∫øn {merged['CALENDAR_DATE'].max().date()}")

except Exception as e:
    st.error(f"L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu: {e}")
    st.stop()

# Ti·∫øp t·ª•c ph·∫ßn ch·ªçn s·∫£n ph·∫©m...
items = merged['ITEM_NAME'].dropna().unique().tolist()

# Sidebar: ch·ªçn 1 ho·∫∑c 2 s·∫£n ph·∫©m
selected_items = st.sidebar.multiselect("üõí Ch·ªçn 1 ho·∫∑c 2 s·∫£n ph·∫©m:", items, max_selections=2)
if not selected_items:
    st.sidebar.info("Ch·ªçn √≠t nh·∫•t 1 s·∫£n ph·∫©m.")
    st.stop()

# L·ªçc d·ªØ li·ªáu theo l·ª±a ch·ªçn
if len(selected_items) == 1:
    df_prod = merged[merged['ITEM_NAME'] == selected_items[0]].copy()
    combo_label = selected_items[0]
else:
    df_prod = merged[merged['ITEM_NAME'].isin(selected_items)].copy()
    combo_label = ' + '.join(selected_items)
    df_prod['ITEM_NAME'] = combo_label

if df_prod.empty:
    st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu cho l·ª±a ch·ªçn n√†y.")
    st.stop()

# X·ª≠ l√Ω d·ªØ li·ªáu chung
df_prod = df_prod.dropna(subset=['PRICE', 'QUANTITY'])
# Lo·∫°i b·ªè outliers b·∫±ng IQR
Q1_price = df_prod['PRICE'].quantile(0.25)
Q3_price = df_prod['PRICE'].quantile(0.75)
IQR_price = Q3_price - Q1_price
lower_bound_price = Q1_price - 1.5 * IQR_price
upper_bound_price = Q3_price + 1.5 * IQR_price

Q1_qty = df_prod['QUANTITY'].quantile(0.25)
Q3_qty = df_prod['QUANTITY'].quantile(0.75)
IQR_qty = Q3_qty - Q1_qty
lower_bound_qty = Q1_qty - 1.5 * IQR_qty
upper_bound_qty = Q3_qty + 1.5 * IQR_qty

df_clean = df_prod[
    (df_prod['PRICE'] >= lower_bound_price) & 
    (df_prod['PRICE'] <= upper_bound_price) &
    (df_prod['QUANTITY'] >= lower_bound_qty) & 
    (df_prod['QUANTITY'] <= upper_bound_qty)
].copy()

# T√≠nh to√°n gi√° trung b√¨nh v√† s·ªë l∆∞·ª£ng theo t·ª´ng m·ª©c gi√°
grp = df_clean.groupby('PRICE')['QUANTITY'].sum().reset_index()
grp['Revenue'] = grp['PRICE'] * grp['QUANTITY']

# Tab UI
tabs = st.tabs([
    "üìã D·ªØ li·ªáu", "üìà Gi√° t·ªëi ∆∞u", "üîç Ph√¢n t√≠ch gi√°", "üí∞ Thay ƒë·ªïi gi√°",
    "üè¢ ƒê·ªëi th·ªß", "üìä So s√°nh gi√° & SL", "üå∏ Xu h∆∞·ªõng theo m√πa", "üìâ Gi·∫£m gi√°",
    "üéØ T·ªëi ∆∞u CTKM", "üì¶ S·∫£n ph·∫©m c·∫ßn ƒëi·ªÅu ch·ªânh", "üë§ ƒê·ªãnh gi√° c√° nh√¢n h√≥a"
])

# Tab 1: D·ªØ li·ªáu
with tabs[0]:
    st.header("üìã D·ªØ li·ªáu sau khi ch·ªçn")
    
    col1, col2 = st.columns(2)
    with col1:
        st.metric("S·ªë l∆∞·ª£ng d·ªØ li·ªáu", f"{len(df_prod):,}")
        st.metric("Gi√° trung b√¨nh", f"{df_prod['PRICE'].mean():.2f}")
    with col2:
        st.metric("S·ªë l∆∞·ª£ng b√°n trung b√¨nh", f"{df_prod['QUANTITY'].mean():.2f}")
        st.metric("Doanh thu trung b√¨nh", f"{(df_prod['PRICE'] * df_prod['QUANTITY']).mean():.2f}")
    
    # Hi·ªÉn th·ªã tr∆∞·ªõc v√† sau khi lo·∫°i b·ªè outliers
    st.subheader("D·ªØ li·ªáu g·ªëc")
    st.dataframe(df_prod.head(10))
    
    st.subheader("D·ªØ li·ªáu sau khi lo·∫°i b·ªè outliers")
    st.dataframe(df_clean.head(10))
    
    # Th·ªëng k√™ m√¥ t·∫£
    st.subheader("Th·ªëng k√™ m√¥ t·∫£")
    st.dataframe(df_clean.describe())

# Tab 2: Gi√° t·ªëi ∆∞u
with tabs[1]:
    st.header("üìà T√¨m Gi√° B√°n T·ªëi ∆Øu")
    
    # Th·ª≠ nhi·ªÅu m√¥ h√¨nh v√† ch·ªçn m√¥ h√¨nh t·ªët nh·∫•t
    X = grp[['PRICE']].values
    y = grp['QUANTITY'].values
    
    # Th·ª≠ b·∫≠c 2 cho m√¥ h√¨nh ƒëa th·ª©c
    poly_features = PolynomialFeatures(degree=2, include_bias=False)
    X_poly = poly_features.fit_transform(X)
    
    # Hu·∫•n luy·ªán m√¥ h√¨nh h·ªìi quy ƒëa th·ª©c
    poly_model = LinearRegression()
    poly_model.fit(X_poly, y)
    
    # T·∫°o gi√° tr·ªã gi√° ƒë·ªÉ d·ª± ƒëo√°n
    price_range = np.linspace(grp['PRICE'].min(), grp['PRICE'].max(), 100)
    X_range = np.array(price_range).reshape(-1, 1)
    X_poly_range = poly_features.transform(X_range)
    
    # D·ª± ƒëo√°n s·ªë l∆∞·ª£ng
    y_pred = poly_model.predict(X_poly_range)
    
    # T√≠nh doanh thu d·ª± ƒëo√°n
    revenue_pred = price_range * y_pred
    
    # T√¨m gi√° t·ªëi ∆∞u t·ª´ m√¥ h√¨nh
    opt_idx = np.argmax(revenue_pred)
    opt_price = price_range[opt_idx]
    opt_revenue = revenue_pred[opt_idx]
    
    col1, col2 = st.columns(2)
    with col1:
        st.metric("üíµ Gi√° t·ªëi ∆∞u t·ª´ d·ªØ li·ªáu th·ª±c t·∫ø", f"{grp.loc[grp['Revenue'].idxmax()]['PRICE']:.2f}")
        st.metric("üí∞ Doanh thu max t·ª´ d·ªØ li·ªáu", f"{grp['Revenue'].max():,.2f}")
    with col2:
        st.metric("üìä Gi√° t·ªëi ∆∞u t·ª´ m√¥ h√¨nh", f"{opt_price:.2f}")
        st.metric("üìà Doanh thu d·ª± ƒëo√°n", f"{opt_revenue:,.2f}")
    
    # Bi·ªÉu ƒë·ªì doanh thu theo gi√°
    pred_df = pd.DataFrame({
        'Gi√°': price_range,
        'Doanh thu d·ª± ƒëo√°n': revenue_pred
    })
    
    chart1 = alt.Chart(grp).mark_circle(size=100).encode(
        x=alt.X('PRICE', title='Gi√°'),
        y=alt.Y('Revenue', title='Doanh thu th·ª±c t·∫ø'),
        tooltip=['PRICE', 'QUANTITY', 'Revenue']
    ).properties(title='Doanh thu th·ª±c t·∫ø theo gi√°')
    
    chart2 = alt.Chart(pred_df).mark_line(color='red').encode(
        x=alt.X('Gi√°', title='Gi√°'),
        y=alt.Y('Doanh thu d·ª± ƒëo√°n', title='Doanh thu d·ª± ƒëo√°n'),
        tooltip=['Gi√°', 'Doanh thu d·ª± ƒëo√°n']
    )
    
    st.altair_chart(chart1 + chart2, use_container_width=True)
    
    # Hi·ªÉn th·ªã ƒëi·ªÉm t·ªëi ∆∞u
    st.markdown(f"**ƒêi·ªÉm gi√° t·ªëi ∆∞u:** {opt_price:.2f} (Doanh thu d·ª± ƒëo√°n: {opt_revenue:,.2f})")
    
    # T√≠nh ph·∫ßn trƒÉm tƒÉng doanh thu so v·ªõi gi√° hi·ªán t·∫°i
    current_price = df_clean['PRICE'].mean()
    current_qty = df_clean['QUANTITY'].mean()
    current_revenue = current_price * current_qty
    
    revenue_increase = (opt_revenue - current_revenue) / current_revenue * 100 if current_revenue > 0 else 0
    st.info(f"N·∫øu thay ƒë·ªïi gi√° t·ª´ {current_price:.2f} th√†nh {opt_price:.2f}, doanh thu d·ª± ki·∫øn s·∫Ω tƒÉng {revenue_increase:.2f}%")

# Tab 3: Ph√¢n t√≠ch gi√°
with tabs[2]:
    st.header("üîé Ph√¢n T√≠ch Gi√° ‚Üî Nhu C·∫ßu")
    
    # T√≠nh h·ªá s·ªë t∆∞∆°ng quan
    corr = grp['PRICE'].corr(grp['QUANTITY'])
    st.write(f"**H·ªá s·ªë t∆∞∆°ng quan gi·ªØa gi√° v√† s·ªë l∆∞·ª£ng:** {corr:.2f}")
    
    if corr < -0.5:
        st.success("üëç C√≥ m·ªëi t∆∞∆°ng quan √¢m m·∫°nh gi·ªØa gi√° v√† s·ªë l∆∞·ª£ng b√°n. Khi gi√° gi·∫£m, s·ªë l∆∞·ª£ng b√°n tƒÉng r√µ r·ªát.")
    elif corr < 0:
        st.info("‚ÑπÔ∏è C√≥ m·ªëi t∆∞∆°ng quan √¢m y·∫øu gi·ªØa gi√° v√† s·ªë l∆∞·ª£ng b√°n. Gi√° c√≥ ·∫£nh h∆∞·ªüng nh∆∞ng kh√¥ng nhi·ªÅu.")
    elif corr == 0:
        st.warning("‚ö†Ô∏è Kh√¥ng c√≥ m·ªëi t∆∞∆°ng quan gi·ªØa gi√° v√† s·ªë l∆∞·ª£ng b√°n. C√≥ th·ªÉ l√† s·∫£n ph·∫©m kh√¥ng nh·∫°y c·∫£m v·ªõi gi√°.")
    else:
        st.error("‚ùó C√≥ m·ªëi t∆∞∆°ng quan d∆∞∆°ng gi·ªØa gi√° v√† s·ªë l∆∞·ª£ng b√°n. ƒê√¢y l√† tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát (h√†ng xa x·ªâ).")
    
    # V·∫Ω bi·ªÉu ƒë·ªì ph√¢n t√°n
    scatter = alt.Chart(grp).mark_circle(size=60).encode(
        x=alt.X('PRICE', title='Gi√°'),
        y=alt.Y('QUANTITY', title='S·ªë l∆∞·ª£ng'),
        size='Revenue',
        color=alt.Color('Revenue', scale=alt.Scale(scheme='viridis')),
        tooltip=['PRICE', 'QUANTITY', 'Revenue']
    ).properties(
        title='M·ªëi quan h·ªá gi·ªØa Gi√° v√† S·ªë l∆∞·ª£ng b√°n'
    ).interactive()
    
    # Th√™m ƒë∆∞·ªùng h·ªìi quy
    regression_line = scatter.transform_regression(
        'PRICE', 'QUANTITY'
    ).mark_line(color='red').encode(
        x='PRICE',
        y='QUANTITY'
    )
    
    st.altair_chart(scatter + regression_line, use_container_width=True)
    
    # T√≠nh ƒë·ªô co gi√£n c·ªßa c·∫ßu (Price Elasticity of Demand)
    avg_price = df_clean['PRICE'].mean()
    avg_qty = df_clean['QUANTITY'].mean()
    
    # S·ª≠ d·ª•ng h·ªá s·ªë h·ªìi quy ƒë·ªÉ t√≠nh ƒë·ªô co gi√£n
    model = LinearRegression().fit(X, y)
    price_elasticity = model.coef_[0] * (avg_price / avg_qty)
    
    st.subheader("Ph√¢n t√≠ch ƒë·ªô co gi√£n c·ªßa c·∫ßu (Price Elasticity)")
    st.metric("ƒê·ªô co gi√£n c·ªßa c·∫ßu", f"{abs(price_elasticity):.2f}")
    
    if abs(price_elasticity) > 1:
        st.success("üìà C·∫ßu c√≥ t√≠nh co gi√£n cao (elastic): Thay ƒë·ªïi gi√° s·∫Ω t·∫°o ra s·ª± thay ƒë·ªïi l·ªõn v·ªÅ s·ªë l∆∞·ª£ng b√°n.")
    elif abs(price_elasticity) < 1:
        st.info("üìâ C·∫ßu k√©m co gi√£n (inelastic): Thay ƒë·ªïi gi√° s·∫Ω kh√¥ng ·∫£nh h∆∞·ªüng nhi·ªÅu ƒë·∫øn s·ªë l∆∞·ª£ng b√°n.")
    else:
        st.warning("‚öñÔ∏è C·∫ßu co gi√£n ƒë∆°n v·ªã (unit elastic): Thay ƒë·ªïi gi√° v√† s·ªë l∆∞·ª£ng b√°n t·ª∑ l·ªá thu·∫≠n v·ªõi nhau.")

# Tab 4: Thay ƒë·ªïi gi√°
with tabs[3]:
    st.header("üìä T√°c ƒê·ªông Thay ƒê·ªïi Gi√° ‚Üí Doanh Thu")
    
    # S·ª≠ d·ª•ng m√¥ h√¨nh ƒëa th·ª©c b·∫≠c 2 ƒë·ªÉ d·ª± ƒëo√°n t·ªët h∆°n
    base_price = df_clean['PRICE'].mean()
    
    # T·∫°o thanh tr∆∞·ª£t ƒë·ªÉ ƒëi·ªÅu ch·ªânh ph·∫ßn trƒÉm thay ƒë·ªïi gi√°
    price_change = st.slider(
        "Thay ƒë·ªïi gi√° (%)", 
        min_value=-30, 
        max_value=30, 
        value=0, 
        step=5,
        help="K√©o thanh tr∆∞·ª£t ƒë·ªÉ xem t√°c ƒë·ªông c·ªßa vi·ªác thay ƒë·ªïi gi√°"
    )
    
    # T√≠nh to√°n gi√° m·ªõi
    new_price = base_price * (1 + price_change/100)
    
    # D·ª± ƒëo√°n s·ªë l∆∞·ª£ng v·ªõi gi√° m·ªõi
    new_price_poly = poly_features.transform(np.array([[new_price]]))
    new_qty = poly_model.predict(new_price_poly)[0]
    new_revenue = new_price * new_qty
    
    # Hi·ªÉn th·ªã k·∫øt qu·∫£
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Gi√° m·ªõi", f"{new_price:.2f}", f"{price_change}%")
    with col2:
        current_qty = df_clean['QUANTITY'].mean()
        qty_change = ((new_qty - current_qty) / current_qty * 100) if current_qty > 0 else 0
        st.metric("S·ªë l∆∞·ª£ng d·ª± ƒëo√°n", f"{new_qty:.2f}", f"{qty_change:.2f}%")
    with col3:
        current_revenue = base_price * current_qty
        rev_change = ((new_revenue - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        st.metric("Doanh thu d·ª± ƒëo√°n", f"{new_revenue:.2f}", f"{rev_change:.2f}%")
    
    # T·∫°o b·∫£ng c√°c m·ª©c thay ƒë·ªïi gi√°
    pct = [-15, -10, -5, 0, 5, 10, 15]
    results = []

    for p in pct:
        adj_price = base_price * (1 + p/100)
        adj_price_poly = poly_features.transform(np.array([[adj_price]]))
        adj_qty = max(0, poly_model.predict(adj_price_poly)[0])  # ƒê·∫£m b·∫£o s·ªë l∆∞·ª£ng kh√¥ng √¢m
        adj_revenue = adj_price * adj_qty
        
        # T√≠nh ph·∫ßn trƒÉm thay ƒë·ªïi so v·ªõi hi·ªán t·∫°i
        qty_pct_change = ((adj_qty - current_qty) / current_qty * 100) if current_qty > 0 else 0
        rev_pct_change = ((adj_revenue - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        
        results.append({
            'Thay ƒë·ªïi gi√° (%)': p,
            'Gi√° m·ªõi': round(adj_price, 2),
            'S·ªë l∆∞·ª£ng d·ª± ƒëo√°n': round(adj_qty, 2),
            'Thay ƒë·ªïi SL (%)': round(qty_pct_change, 2),
            'Doanh thu d·ª± ƒëo√°n': round(adj_revenue, 2),
            'Thay ƒë·ªïi doanh thu (%)': round(rev_pct_change, 2)
        })

    # Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£
    result_df = pd.DataFrame(results)
    st.subheader("B·∫£ng t√°c ƒë·ªông thay ƒë·ªïi gi√°")
    st.dataframe(result_df)

    # Debugging: Check columns and data
    st.write("Columns in result_df:", result_df.columns.tolist())
    if result_df[['Doanh thu d·ª± ƒëo√°n', 'S·ªë l∆∞·ª£ng d·ª± ƒëo√°n']].isna().any().any():
        st.warning("Warning: NaN values detected in 'Doanh thu d·ª± ƒëo√°n' or 'S·ªë l∆∞·ª£ng d·ª± ƒëo√°n'.")

    # Melt the DataFrame to long format
    melted_df = result_df.melt(
        id_vars=['Thay ƒë·ªïi gi√° (%)'],
        value_vars=['Doanh thu d·ª± ƒëo√°n', 'S·ªë l∆∞·ª£ng d·ª± ƒëo√°n'],
        var_name='Ch·ªâ s·ªë',
        value_name='Gi√° tr·ªã'
    )

    # Debugging: Inspect melted DataFrame
    st.write("Melted DataFrame:", melted_df.head())

    # Create the Altair chart using the melted DataFrame
    chart = alt.Chart(melted_df).mark_line(point=True).encode(
        x=alt.X('Thay ƒë·ªïi gi√° (%):Q', title='Thay ƒë·ªïi gi√° (%)'),
        y=alt.Y('Gi√° tr·ªã:Q', title='Gi√° tr·ªã'),
        color=alt.Color('Ch·ªâ s·ªë:N', title='Ch·ªâ s·ªë'),
        tooltip=['Thay ƒë·ªïi gi√° (%)', 'Ch·ªâ s·ªë', 'Gi√° tr·ªã']
    ).properties(
        title='T√°c ƒë·ªông c·ªßa thay ƒë·ªïi gi√° ƒë·∫øn s·ªë l∆∞·ª£ng v√† doanh thu'
    )

    # Display the chart in Streamlit
    st.altair_chart(chart, use_container_width=True)

# Tab 5: ƒê·ªëi th·ªß
with tabs[4]:
    st.header("ü§ù Ph√¢n t√≠ch c·∫°nh tranh")
    st.write(f"S·∫£n ph·∫©m/Combo: **{combo_label}**")
    
    # Cho ph√©p ng∆∞·ªùi d√πng nh·∫≠p th√¥ng tin ƒë·ªëi th·ªß
    st.subheader("Th√¥ng tin ƒë·ªëi th·ªß")
    
    col1, col2 = st.columns(2)
    with col1:
        competitor_names = st.text_area(
            "T√™n ƒë·ªëi th·ªß (m·ªói d√≤ng m·ªôt t√™n)",
            "ƒê·ªëi th·ªß A\nƒê·ªëi th·ªß B\nƒê·ªëi th·ªß C",
            help="Nh·∫≠p t√™n c√°c ƒë·ªëi th·ªß, m·ªói ƒë·ªëi th·ªß m·ªôt d√≤ng"
        ).strip().split("\n")
    
    with col2:
        competitor_prices = st.text_area(
            "Gi√° c·ªßa ƒë·ªëi th·ªß (m·ªói d√≤ng m·ªôt gi√°)",
            f"{base_price*0.95:.2f}\n{base_price*1.05:.2f}\n{base_price*1.15:.2f}",
            help="Nh·∫≠p gi√° c·ªßa t·ª´ng ƒë·ªëi th·ªß, m·ªói gi√° m·ªôt d√≤ng, theo th·ª© t·ª± t∆∞∆°ng ·ª©ng v·ªõi t√™n ƒë·ªëi th·ªß"
        ).strip().split("\n")
    
    # Ki·ªÉm tra ƒë·∫ßu v√†o
    if len(competitor_names) != len(competitor_prices):
        st.error("S·ªë l∆∞·ª£ng t√™n ƒë·ªëi th·ªß v√† gi√° kh√¥ng kh·ªõp nhau!")
    else:
        # Chuy·ªÉn ƒë·ªïi gi√° sang s·ªë
        try:
            competitor_prices = [float(price) for price in competitor_prices]
            
            # T·∫°o d·ªØ li·ªáu ƒë·ªëi th·ªß
            competitors = {}
            for name, price in zip(competitor_names, competitor_prices):
                competitors[name] = price
            
            # Ph√¢n t√≠ch th·ªã ph·∫ßn d·ª±a tr√™n m√¥ h√¨nh
            data = []
            total_q = 0
            
            # T√≠nh s·ªë l∆∞·ª£ng b√°n d·ª± ƒëo√°n cho t·ª´ng ƒë·ªëi th·ªß v√† t·ªïng
            for name, price in competitors.items():
                price_poly = poly_features.transform(np.array([[price]]))
                q = max(0, poly_model.predict(price_poly)[0])
                r = price * q
                total_q += q
                data.append((name, price, q, r))
            
            # Th√™m d·ªØ li·ªáu c·ªßa shop c·ªßa m√¨nh
            own_shop_name = "Shop c·ªßa b·∫°n"
            own_q = df_clean['QUANTITY'].mean()
            own_r = base_price * own_q
            total_q += own_q
            data.append((own_shop_name, base_price, own_q, own_r))
            
            # T√≠nh th·ªã ph·∫ßn
            df_comp = pd.DataFrame(data, columns=['ƒê·ªëi th·ªß', 'Gi√°', 'SL d·ª± ƒëo√°n', 'Doanh thu'])
            df_comp['Th·ªã ph·∫ßn (%)'] = (df_comp['SL d·ª± ƒëo√°n'] / total_q * 100).round(2)
            
            # Hi·ªÉn th·ªã b·∫£ng ph√¢n t√≠ch
            st.subheader("Ph√¢n t√≠ch c·∫°nh tranh d·ª±a tr√™n gi√°")
            st.dataframe(df_comp)
            
            # V·∫Ω bi·ªÉu ƒë·ªì th·ªã ph·∫ßn
            chart1 = alt.Chart(df_comp).mark_arc().encode(
                theta=alt.Theta(field="Th·ªã ph·∫ßn (%)", type="quantitative"),
                color=alt.Color(field="ƒê·ªëi th·ªß", type="nominal", legend=alt.Legend(title="ƒê·ªëi th·ªß")),
                tooltip=['ƒê·ªëi th·ªß', 'Gi√°', 'SL d·ª± ƒëo√°n', 'Th·ªã ph·∫ßn (%)']
            ).properties(title="Th·ªã ph·∫ßn d·ª± ƒëo√°n", width=300, height=300)
            
            # V·∫Ω bi·ªÉu ƒë·ªì so s√°nh gi√°
            chart2 = alt.Chart(df_comp).mark_bar().encode(
                x=alt.X('ƒê·ªëi th·ªß:N', title='ƒê·ªëi th·ªß'),
                y=alt.Y('Gi√°:Q', title='Gi√°'),
                color=alt.Color('ƒê·ªëi th·ªß:N', legend=None),
                tooltip=['ƒê·ªëi th·ªß', 'Gi√°']
            ).properties(title="So s√°nh gi√° gi·ªØa c√°c ƒë·ªëi th·ªß", width=300, height=300)
            
            # Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì
            st.altair_chart(alt.hconcat(chart1, chart2), use_container_width=True)
            
            # Ph√¢n t√≠ch v·ªã th·∫ø c·∫°nh tranh
            own_position = df_comp[df_comp['ƒê·ªëi th·ªß'] == own_shop_name].iloc[0]
            competitors_df = df_comp[df_comp['ƒê·ªëi th·ªß'] != own_shop_name]
            
            # So s√°nh gi√°
            avg_competitor_price = competitors_df['Gi√°'].mean()
            price_difference = ((base_price - avg_competitor_price) / avg_competitor_price) * 100
            
            st.subheader("Ph√¢n t√≠ch v·ªã th·∫ø c·∫°nh tranh")
            if price_difference > 5:
                st.warning(f"‚ö†Ô∏è Gi√° c·ªßa b·∫°n cao h∆°n {abs(price_difference):.2f}% so v·ªõi gi√° trung b√¨nh c·ªßa ƒë·ªëi th·ªß.")
            elif price_difference < -5:
                st.success(f"‚úÖ Gi√° c·ªßa b·∫°n th·∫•p h∆°n {abs(price_difference):.2f}% so v·ªõi gi√° trung b√¨nh c·ªßa ƒë·ªëi th·ªß.")
            else:
                st.info(f"‚ÑπÔ∏è Gi√° c·ªßa b·∫°n t∆∞∆°ng ƒë∆∞∆°ng v·ªõi gi√° trung b√¨nh c·ªßa ƒë·ªëi th·ªß (ch√™nh l·ªách {price_difference:.2f}%).")
            
            # ƒê·ªÅ xu·∫•t chi·∫øn l∆∞·ª£c
            st.subheader("ƒê·ªÅ xu·∫•t chi·∫øn l∆∞·ª£c c·∫°nh tranh")
            if own_position['Th·ªã ph·∫ßn (%)'] < 20:
                if price_difference > 5:
                    st.error("‚ùó Th·ªã ph·∫ßn th·∫•p v√† gi√° cao h∆°n ƒë·ªëi th·ªß. N√™n xem x√©t gi·∫£m gi√° ƒë·ªÉ tƒÉng kh·∫£ nƒÉng c·∫°nh tranh.")
                else:
                    st.warning("‚ö†Ô∏è Th·ªã ph·∫ßn th·∫•p. N√™n xem x√©t c√°c y·∫øu t·ªë kh√°c ngo√†i gi√° nh∆∞ ch·∫•t l∆∞·ª£ng, d·ªãch v·ª• ƒë·ªÉ tƒÉng kh·∫£ nƒÉng c·∫°nh tranh.")
            else:
                if price_difference < -5:
                    st.success("‚úÖ Th·ªã ph·∫ßn t·ªët v√† gi√° th·∫•p h∆°n ƒë·ªëi th·ªß. C√≥ th·ªÉ xem x√©t tƒÉng gi√° ƒë·ªÉ t·ªëi ∆∞u doanh thu.")
                else:
                    st.success("üëç V·ªã th·∫ø c·∫°nh tranh t·ªët. N√™n duy tr√¨ chi·∫øn l∆∞·ª£c hi·ªán t·∫°i v√† theo d√µi ƒë·ªëi th·ªß.")
            
        except ValueError as e:
            st.error(f"L·ªói khi x·ª≠ l√Ω d·ªØ li·ªáu ƒë·ªëi th·ªß: {e}")

# Tab 6: So s√°nh gi√° & SL
with tabs[5]:
    st.header("üìä Nh·∫°y C·∫£m Gi√° ‚Äì D·ª±a tr√™n DateInfo")

    # Chu·∫©n h√≥a bi·∫øn ng√†y th√°ng
    df = df_clean.copy()
    
    # Ki·ªÉm tra c√°c c·ªôt c·∫ßn thi·∫øt c√≥ t·ªìn t·∫°i kh√¥ng
    date_cols = []
    if 'HOLIDAY' in df.columns:
        df['IS_HOLIDAY'] = df['HOLIDAY'].notna().astype(int)
        date_cols.append('IS_HOLIDAY')
    
    if 'IS_WEEKEND' in df.columns:
        date_cols.append('IS_WEEKEND')
    elif 'CALENDAR_DATE' in df.columns:
        # T·∫°o c·ªôt IS_WEEKEND n·∫øu ch∆∞a c√≥
        df['IS_WEEKEND'] = df['CALENDAR_DATE'].dt.weekday >= 5
        date_cols.append('IS_WEEKEND')
    
    if 'IS_SCHOOLBREAK' in df.columns:
        date_cols.append('IS_SCHOOLBREAK')
    
    if 'IS_OUTDOOR' in df.columns:
        date_cols.append('IS_OUTDOOR')
    
    if not date_cols:
        st.warning("Kh√¥ng t√¨m th·∫•y c·ªôt ng√†y th√°ng ph√π h·ª£p trong d·ªØ li·ªáu.")
    else:
        # T√≠nh elasticity theo c√°ch an to√†n
        df = df.sort_values('CALENDAR_DATE')
        df['ŒîP'] = df['PRICE'].pct_change()
        df['ŒîQ'] = df['QUANTITY'].pct_change()
        
        # Lo·∫°i b·ªè c√°c gi√° tr·ªã kh√¥ng h·ª£p l·ªá v√† chia 0
        df = df.dropna(subset=['ŒîP', 'ŒîQ'])
        df = df[df['ŒîP'] != 0]  # Tr√°nh chia cho 0
        
        df['Elasticity'] = df['ŒîQ'] / df['ŒîP']
        
        # Lo·∫°i b·ªè c√°c elasticity qu√° l·ªõn (outliers)
        Q1_el = df['Elasticity'].quantile(0.25)
        Q3_el = df['Elasticity'].quantile(0.75)
        IQR_el = Q3_el - Q1_el
        lower_bound_el = Q1_el - 3 * IQR_el
        upper_bound_el = Q3_el + 3 * IQR_el
        
        df = df[(df['Elasticity'] >= lower_bound_el) & (df['Elasticity'] <= upper_bound_el)]
        
        # Ph√¢n t√≠ch elasticity theo t·ª´ng y·∫øu t·ªë ng√†y th√°ng
        records = []
        
        for factor in date_cols:
            try:
                grp = df.groupby(factor)['Elasticity'].mean().reset_index()
                grp.columns = [factor, 'Elasticity_TB']
                
                for _, row in grp.iterrows():
                    factor_value = "C√≥" if row[factor] == 1 else "Kh√¥ng"
                    records.append({
                        'Y·∫øu t·ªë': factor.replace('IS_', ''),
                        'Gi√° tr·ªã': factor_value,
                        'Elasticity trung b√¨nh': round(row['Elasticity_TB'], 2)
                    })
            except Exception as e:
                st.warning(f"Kh√¥ng th·ªÉ t√≠nh elasticity cho y·∫øu t·ªë {factor}: {e}")
        
        if records:
            df_el = pd.DataFrame(records)
            
            # Hi·ªÉn th·ªã b·∫£ng elasticity
            st.subheader("Elasticity trung b√¨nh theo y·∫øu t·ªë")
            st.dataframe(df_el)
            
            # V·∫Ω bi·ªÉu ƒë·ªì
            for factor in df_el['Y·∫øu t·ªë'].unique():
                df_plot = df_el[df_el['Y·∫øu t·ªë'] == factor]
                
                chart = alt.Chart(df_plot).mark_bar().encode(
                    x=alt.X('Gi√° tr·ªã:O', title=factor),
                    y=alt.Y('Elasticity trung b√¨nh:Q', title='Elasticity trung b√¨nh'),
                    color=alt.Color('Gi√° tr·ªã:N', legend=None),
                    tooltip=['Y·∫øu t·ªë', 'Gi√° tr·ªã', 'Elasticity trung b√¨nh']
                ).properties(title=f"Elasticity theo {factor}", width=300)
                
                st.altair_chart(chart, use_container_width=True)
            
            # Ph√¢n t√≠ch k·∫øt qu·∫£
            st.subheader("Ph√¢n t√≠ch nh·∫°y c·∫£m gi√° theo ƒëi·ªÅu ki·ªán")
            
            for factor in df_el['Y·∫øu t·ªë'].unique():
                factor_data = df_el[df_el['Y·∫øu t·ªë'] == factor]
                
                if len(factor_data) >= 2:
                    values = factor_data['Elasticity trung b√¨nh'].values
                    diff = abs(values[0] - values[1])
                    
                    if diff > 0.5:
                        st.info(f"üìå **{factor}**: C√≥ s·ª± kh√°c bi·ªát l·ªõn v·ªÅ nh·∫°y c·∫£m gi√° ({diff:.2f}). N√™n xem x√©t ƒëi·ªÅu ch·ªânh gi√° theo y·∫øu t·ªë n√†y.")
                    else:
                        st.write(f"üìå **{factor}**: Kh√¥ng c√≥ nhi·ªÅu s·ª± kh√°c bi·ªát v·ªÅ nh·∫°y c·∫£m gi√° ({diff:.2f}).")

# Tab 7: Xu h∆∞·ªõng theo m√πa
with tabs[6]:
    st.header("üå∏ D·ª± ƒëo√°n xu h∆∞·ªõng thay ƒë·ªïi gi√° theo m√πa v·ª•")
    
    # Ph√¢n lo·∫°i c√°c ng√†y trong nƒÉm theo b·ªën m√πa
    def classify_season(date):
        if date.month in [3, 4, 5]:  # Xu√¢n
            return 'Xu√¢n'
        elif date.month in [6, 7, 8]:  # H·∫°
            return 'H·∫°'
        elif date.month in [9, 10, 11]:  # Thu
            return 'Thu'
        else:  # ƒê√¥ng
            return 'ƒê√¥ng'

    # Th√™m c·ªôt M√πa v√†o dataframe
    df_season = df_clean.copy()
    if 'CALENDAR_DATE' in df_season.columns:
        df_season['Season'] = df_season['CALENDAR_DATE'].apply(classify_season)
        
        # Nh√≥m d·ªØ li·ªáu theo m√πa v√† t√≠nh trung b√¨nh gi√° v√† s·ªë l∆∞·ª£ng
        season_avg = df_season.groupby('Season').agg({
            'PRICE': 'mean',
            'QUANTITY': 'mean'
        }).reset_index()
        
        season_avg['Revenue'] = season_avg['PRICE'] * season_avg['QUANTITY']
        
        # Th√™m c√°c th√¥ng tin kh√°c n·∫øu c√≥
        if 'IS_WEEKEND' in df_season.columns:
            season_weekend_avg = df_season[df_season['IS_WEEKEND'] == 1].groupby('Season').agg({
                'PRICE': 'mean',
                'QUANTITY': 'mean'
            }).reset_index()
            season_weekend_avg = season_weekend_avg.rename(columns={
                'PRICE': 'PRICE_WEEKEND',
                'QUANTITY': 'QUANTITY_WEEKEND'
            })
            season_avg = pd.merge(season_avg, season_weekend_avg, on='Season', how='left')
        
        # Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£
        st.subheader("Ph√¢n t√≠ch theo m√πa")
        st.dataframe(season_avg)
        
        # V·∫Ω bi·ªÉu ƒë·ªì gi√° theo m√πa
        chart1 = alt.Chart(season_avg).mark_bar().encode(
            x=alt.X('Season:O', title='M√πa', sort=['Xu√¢n', 'H·∫°', 'Thu', 'ƒê√¥ng']),
            y=alt.Y('PRICE:Q', title='Gi√° trung b√¨nh'),
            color=alt.Color('Season:N', legend=None),
            tooltip=['Season', 'PRICE', 'QUANTITY', 'Revenue']
        ).properties(title="Gi√° trung b√¨nh theo m√πa")
        
        # V·∫Ω bi·ªÉu ƒë·ªì s·ªë l∆∞·ª£ng theo m√πa
        chart2 = alt.Chart(season_avg).mark_bar().encode(
            x=alt.X('Season:O', title='M√πa', sort=['Xu√¢n', 'H·∫°', 'Thu', 'ƒê√¥ng']),
            y=alt.Y('QUANTITY:Q', title='S·ªë l∆∞·ª£ng trung b√¨nh'),
            color=alt.Color('Season:N', legend=None),
            tooltip=['Season', 'PRICE', 'QUANTITY', 'Revenue']
        ).properties(title="S·ªë l∆∞·ª£ng trung b√¨nh theo m√πa")
        
        # V·∫Ω bi·ªÉu ƒë·ªì doanh thu theo m√πa
        chart3 = alt.Chart(season_avg).mark_bar().encode(
            x=alt.X('Season:O', title='M√πa', sort=['Xu√¢n', 'H·∫°', 'Thu', 'ƒê√¥ng']),
            y=alt.Y('Revenue:Q', title='Doanh thu trung b√¨nh'),
            color=alt.Color('Season:N', legend=None),
            tooltip=['Season', 'PRICE', 'QUANTITY', 'Revenue']
        ).properties(title="Doanh thu trung b√¨nh theo m√πa")
        
        # Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì
        st.altair_chart(alt.vconcat(chart1, chart2, chart3), use_container_width=True)
        
        # ƒê·ªÅ xu·∫•t ƒëi·ªÅu ch·ªânh gi√° theo m√πa
        st.subheader("ƒê·ªÅ xu·∫•t ƒëi·ªÅu ch·ªânh gi√° theo m√πa")
        
        # T√¨m m√πa c√≥ doanh thu cao nh·∫•t v√† th·∫•p nh·∫•t
        max_revenue_season = season_avg.loc[season_avg['Revenue'].idxmax()]['Season']
        min_revenue_season = season_avg.loc[season_avg['Revenue'].idxmin()]['Season']
        
        # T√≠nh ph·∫ßn trƒÉm ch√™nh l·ªách
        max_revenue = season_avg['Revenue'].max()
        min_revenue = season_avg['Revenue'].min()
        revenue_diff_pct = ((max_revenue - min_revenue) / min_revenue) * 100 if min_revenue > 0 else 0
        
        if revenue_diff_pct > 20:
            st.success(f"‚úÖ C√≥ s·ª± ch√™nh l·ªách ƒë√°ng k·ªÉ v·ªÅ doanh thu gi·ªØa c√°c m√πa ({revenue_diff_pct:.2f}%). N√™n xem x√©t ƒëi·ªÅu ch·ªânh gi√° theo m√πa.")
            
            # ƒê·ªÅ xu·∫•t c·ª• th·ªÉ cho t·ª´ng m√πa
            for _, row in season_avg.iterrows():
                season = row['Season']
                price = row['PRICE']
                quantity = row['QUANTITY']
                revenue = row['Revenue']
                
                if season == max_revenue_season:
                    st.info(f"üìà **{season}**: C√≥ doanh thu cao nh·∫•t. C√≥ th·ªÉ tƒÉng gi√° th√™m 5-10% ƒë·ªÉ t·ªëi ∆∞u l·ª£i nhu·∫≠n.")
                elif season == min_revenue_season:
                    st.warning(f"üìâ **{season}**: C√≥ doanh thu th·∫•p nh·∫•t. N√™n khuy·∫øn m√£i ho·∫∑c gi·∫£m gi√° 5-10% ƒë·ªÉ k√≠ch th√≠ch nhu c·∫ßu.")
                else:
                    if revenue > season_avg['Revenue'].mean():
                        st.write(f"üìä **{season}**: Doanh thu kh√° t·ªët. C√≥ th·ªÉ gi·ªØ nguy√™n gi√° ho·∫∑c tƒÉng nh·∫π 2-5%.")
                    else:
                        st.write(f"üìä **{season}**: Doanh thu d∆∞·ªõi m·ª©c trung b√¨nh. C√≥ th·ªÉ gi·∫£m nh·∫π gi√° 2-5% ƒë·ªÉ k√≠ch th√≠ch nhu c·∫ßu.")
        else:
            st.info(f"‚ÑπÔ∏è Kh√¥ng c√≥ s·ª± ch√™nh l·ªách ƒë√°ng k·ªÉ v·ªÅ doanh thu gi·ªØa c√°c m√πa ({revenue_diff_pct:.2f}%). C√≥ th·ªÉ gi·ªØ nguy√™n gi√° xuy√™n su·ªët nƒÉm.")
    else:
        st.warning("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ng√†y th√°ng ƒë·ªÉ ph√¢n t√≠ch theo m√πa.")

# Tab 8: Ph√¢n t√≠ch t√°c ƒë·ªông gi·∫£m gi√°
with tabs[7]:
    st.header("üìâ T√°c ƒê·ªông C·ªßa Gi·∫£m Gi√° ƒê·∫øn L∆∞·ª£ng H√†ng B√°n Ra")
    
    # T·∫°o thanh slider ƒë·ªÉ ƒëi·ªÅu ch·ªânh m·ª©c gi·∫£m gi√°
    discount_pct = st.slider(
        "M·ª©c gi·∫£m gi√° (%)",
        min_value=0,
        max_value=50,
        value=10,
        step=5,
        help="K√©o thanh tr∆∞·ª£t ƒë·ªÉ ƒëi·ªÅu ch·ªânh m·ª©c gi·∫£m gi√° v√† xem t√°c ƒë·ªông"
    )
    
    # T√≠nh gi√° sau gi·∫£m gi√°
    discounted_price = base_price * (1 - discount_pct/100)
    
    # D·ª± ƒëo√°n s·ªë l∆∞·ª£ng b√°n v·ªõi gi√° gi·∫£m
    discounted_price_poly = poly_features.transform(np.array([[discounted_price]]))
    discounted_qty = max(0, poly_model.predict(discounted_price_poly)[0])
    discounted_revenue = discounted_price * discounted_qty
    
    # Hi·ªÉn th·ªã k·∫øt qu·∫£
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Gi√° sau gi·∫£m", f"{discounted_price:.2f}", f"-{discount_pct}%")
    with col2:
        current_qty = df_clean['QUANTITY'].mean()
        qty_change = ((discounted_qty - current_qty) / current_qty * 100) if current_qty > 0 else 0
        st.metric("S·ªë l∆∞·ª£ng d·ª± ƒëo√°n", f"{discounted_qty:.2f}", f"+{qty_change:.2f}%" if qty_change > 0 else f"{qty_change:.2f}%")
    with col3:
        current_revenue = base_price * current_qty
        rev_change = ((discounted_revenue - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        st.metric("Doanh thu d·ª± ƒëo√°n", f"{discounted_revenue:.2f}", f"+{rev_change:.2f}%" if rev_change > 0 else f"{rev_change:.2f}%")
    
    # T·∫°o b·∫£ng c√°c m·ª©c gi·∫£m gi√°
    discount_range = range(0, 55, 5)
    results = []
    
    for d in discount_range:
        adj_price = base_price * (1 - d/100)
        adj_price_poly = poly_features.transform(np.array([[adj_price]]))
        adj_qty = max(0, poly_model.predict(adj_price_poly)[0])
        adj_revenue = adj_price * adj_qty
        
        # T√≠nh ph·∫ßn trƒÉm thay ƒë·ªïi so v·ªõi kh√¥ng gi·∫£m gi√°
        qty_pct_change = ((adj_qty - current_qty) / current_qty * 100) if current_qty > 0 else 0
        rev_pct_change = ((adj_revenue - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        
        results.append({
            'Gi·∫£m gi√° (%)': d,
            'Gi√° sau gi·∫£m': round(adj_price, 2),
            'S·ªë l∆∞·ª£ng d·ª± ƒëo√°n': round(adj_qty, 2),
            'Thay ƒë·ªïi SL (%)': round(qty_pct_change, 2),
            'Doanh thu d·ª± ƒëo√°n': round(adj_revenue, 2),
            'Thay ƒë·ªïi doanh thu (%)': round(rev_pct_change, 2)
        })
    
    # T√¨m m·ª©c gi·∫£m gi√° t·ªëi ∆∞u (doanh thu cao nh·∫•t)
    result_df = pd.DataFrame(results)
    opt_discount = result_df.loc[result_df['Doanh thu d·ª± ƒëo√°n'].idxmax()]
    
    # Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£
    st.subheader("Ph√¢n t√≠ch c√°c m·ª©c gi·∫£m gi√° kh√°c nhau")
    st.dataframe(result_df)
    
    # Hi·ªÉn th·ªã m·ª©c gi·∫£m gi√° t·ªëi ∆∞u
    st.success(f"‚úÖ M·ª©c gi·∫£m gi√° t·ªëi ∆∞u: **{opt_discount['Gi·∫£m gi√° (%)']}%** - Doanh thu d·ª± ƒëo√°n: **{opt_discount['Doanh thu d·ª± ƒëo√°n']:.2f}** (+{opt_discount['Thay ƒë·ªïi doanh thu (%)']:.2f}%)")
    
    # V·∫Ω bi·ªÉu ƒë·ªì
    chart = alt.Chart(result_df).mark_line(point=True).encode(
        x=alt.X('Gi·∫£m gi√° (%):Q', title='Gi·∫£m gi√° (%)'),
        y=alt.Y('Doanh thu d·ª± ƒëo√°n:Q', title='Doanh thu d·ª± ƒëo√°n'),
        tooltip=['Gi·∫£m gi√° (%)', 'Gi√° sau gi·∫£m', 'S·ªë l∆∞·ª£ng d·ª± ƒëo√°n', 'Doanh thu d·ª± ƒëo√°n', 'Thay ƒë·ªïi doanh thu (%)']
    ).properties(
        title='T√°c ƒë·ªông c·ªßa gi·∫£m gi√° ƒë·∫øn doanh thu'
    )
    
    # ƒê√°nh d·∫•u ƒëi·ªÉm t·ªëi ∆∞u
    highlight = alt.Chart(pd.DataFrame([opt_discount])).mark_circle(size=100, color='red').encode(
        x='Gi·∫£m gi√° (%):Q', 
        y='Doanh thu d·ª± ƒëo√°n:Q'
    )
    
    st.altair_chart(chart + highlight, use_container_width=True)
    
    # Ph√¢n t√≠ch chi ti·∫øt
    st.subheader("Ph√¢n t√≠ch chi ti·∫øt")
    
    if opt_discount['Gi·∫£m gi√° (%)'] == 0:
        st.info("‚ÑπÔ∏è Kh√¥ng c·∫ßn gi·∫£m gi√° - Gi√° hi·ªán t·∫°i ƒë√£ t·ªëi ∆∞u cho doanh thu.")
    elif opt_discount['Gi·∫£m gi√° (%)'] <= 15:
        st.info(f"‚ÑπÔ∏è M·ª©c gi·∫£m gi√° nh·∫π ({opt_discount['Gi·∫£m gi√° (%)']}%) c√≥ th·ªÉ tƒÉng doanh thu. N√™n xem x√©t √°p d·ª•ng cho c√°c ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i ng·∫Øn h·∫°n.")
    elif opt_discount['Gi·∫£m gi√° (%)'] <= 30:
        st.warning(f"‚ö†Ô∏è M·ª©c gi·∫£m gi√° trung b√¨nh ({opt_discount['Gi·∫£m gi√° (%)']}%) c√≥ th·ªÉ t·ªëi ∆∞u doanh thu, nh∆∞ng c·∫ßn c√¢n nh·∫Øc v·ªÅ l·ª£i nhu·∫≠n. Ph√π h·ª£p cho c√°c s·ª± ki·ªán l·ªõn.")
    else:
        st.error(f"‚ùó M·ª©c gi·∫£m gi√° cao ({opt_discount['Gi·∫£m gi√° (%)']}%) cho th·∫•y gi√° hi·ªán t·∫°i c√≥ th·ªÉ qu√° cao so v·ªõi m·ª©c ch·∫•p nh·∫≠n c·ªßa kh√°ch h√†ng. N√™n xem x√©t ƒëi·ªÅu ch·ªânh gi√° c∆° b·∫£n.")

# Tab 9: T·ªëi ∆∞u ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i
with tabs[8]:
    st.header("üéØ T·ªëi ∆∞u h√≥a ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i d·ª±a tr√™n gi√°")
    
    # T·∫°o c√°c l·ª±a ch·ªçn cho lo·∫°i CTKM
    promo_type = st.radio(
        "Lo·∫°i ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i",
        ["Gi·∫£m gi√° tr·ª±c ti·∫øp", "Mua 1 t·∫∑ng 1", "Combo gi·∫£m gi√°", "Gi·∫£m gi√° theo s·ªë l∆∞·ª£ng"],
        horizontal=True
    )
    
    if promo_type == "Gi·∫£m gi√° tr·ª±c ti·∫øp":
        st.subheader("Gi·∫£m gi√° tr·ª±c ti·∫øp")
        
        # Gi·∫£ ƒë·ªãnh v·ªÅ chi ph√≠ v√† l·ª£i nhu·∫≠n
        cost_pct = st.slider(
            "Chi ph√≠ (% gi√° b√°n)", 30, 70, 50, 5, 
            help="Chi ph√≠ s·∫£n xu·∫•t/nh·∫≠p h√†ng t√≠nh theo % gi√° b√°n",
            key="cost_pct_direct_discount"
        )
        cost_price = base_price * (cost_pct / 100)
        
        # T√≠nh to√°n l·ª£i nhu·∫≠n cho c√°c m·ª©c gi·∫£m gi√°
        profit_results = []
        
        for d in discount_range:
            adj_price = base_price * (1 - d/100)
            adj_price_poly = poly_features.transform(np.array([[adj_price]]))
            adj_qty = max(0, poly_model.predict(adj_price_poly)[0])
            adj_revenue = adj_price * adj_qty
            adj_profit = (adj_price - cost_price) * adj_qty
            
            # T√≠nh ph·∫ßn trƒÉm thay ƒë·ªïi
            current_profit = (base_price - cost_price) * current_qty
            profit_pct_change = ((adj_profit - current_profit) / current_profit * 100) if current_profit > 0 else 0
            
            profit_results.append({
                'Gi·∫£m gi√° (%)': d,
                'Gi√° sau gi·∫£m': round(adj_price, 2),
                'S·ªë l∆∞·ª£ng d·ª± ƒëo√°n': round(adj_qty, 2),
                'Doanh thu d·ª± ƒëo√°n': round(adj_revenue, 2),
                'L·ª£i nhu·∫≠n d·ª± ƒëo√°n': round(adj_profit, 2),
                'Thay ƒë·ªïi l·ª£i nhu·∫≠n (%)': round(profit_pct_change, 2)
            })
        
        # T√¨m m·ª©c gi·∫£m gi√° t·ªëi ∆∞u (l·ª£i nhu·∫≠n cao nh·∫•t)
        profit_df = pd.DataFrame(profit_results)
        opt_profit_discount = profit_df.loc[profit_df['L·ª£i nhu·∫≠n d·ª± ƒëo√°n'].idxmax()]
        
        # Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£
        st.dataframe(profit_df)
        
        # Hi·ªÉn th·ªã m·ª©c gi·∫£m gi√° t·ªëi ∆∞u cho l·ª£i nhu·∫≠n
        st.success(f"‚úÖ M·ª©c gi·∫£m gi√° t·ªëi ∆∞u cho l·ª£i nhu·∫≠n: **{opt_profit_discount['Gi·∫£m gi√° (%)']}%** - L·ª£i nhu·∫≠n d·ª± ƒëo√°n: **{opt_profit_discount['L·ª£i nhu·∫≠n d·ª± ƒëo√°n']:.2f}** (+{opt_profit_discount['Thay ƒë·ªïi l·ª£i nhu·∫≠n (%)']:.2f}%)")
        
        # Ki·ªÉm tra d·ªØ li·ªáu tr∆∞·ªõc khi v·∫Ω bi·ªÉu ƒë·ªì
        st.write("D·ªØ li·ªáu ƒë·∫ßu v√†o:", profit_df.head())
        st.write("Danh s√°ch c·ªôt:", profit_df.columns.tolist())

        melted_df = profit_df.melt(
            id_vars=['Gi·∫£m gi√° (%)'], 
            value_vars=['Doanh thu d·ª± ƒëo√°n', 'L·ª£i nhu·∫≠n d·ª± ƒëo√°n'], 
            var_name='Ch·ªâ s·ªë', 
            value_name='Gi√° tr·ªã'
        )
        # V·∫Ω bi·ªÉu ƒë·ªì so s√°nh doanh thu v√† l·ª£i nhu·∫≠n
        chart = alt.Chart(melted_df).mark_line(point=True).encode(
            x=alt.X('Gi·∫£m gi√° (%):Q', title='Gi·∫£m gi√° (%)'),
            y=alt.Y('Gi√° tr·ªã:Q', title='Gi√° tr·ªã'),
            color=alt.Color('Ch·ªâ s·ªë:N', title='Ch·ªâ s·ªë'),
            tooltip=['Gi·∫£m gi√° (%)', 'Ch·ªâ s·ªë', 'Gi√° tr·ªã']
        ).properties(
            title='So s√°nh doanh thu v√† l·ª£i nhu·∫≠n theo m·ª©c gi·∫£m gi√°'
        )
        
        st.altair_chart(chart, use_container_width=True)
        
    elif promo_type == "Mua 1 t·∫∑ng 1":
        st.subheader("Ph√¢n t√≠ch ch∆∞∆°ng tr√¨nh Mua 1 t·∫∑ng 1")
        
        # Chi ph√≠ s·∫£n xu·∫•t/nh·∫≠p h√†ng
        cost_pct = st.slider(
            "Chi ph√≠ (% gi√° b√°n)", 30, 70, 50, 5, 
            help="Chi ph√≠ s·∫£n xu·∫•t/nh·∫≠p h√†ng t√≠nh theo % gi√° b√°n",
            key="cost_pct_bogo"
        )
        cost_price = base_price * (cost_pct / 100)
        
        # T√≠nh to√°n
        effective_discount = 50  # Mua 1 t·∫∑ng 1 t∆∞∆°ng ƒë∆∞∆°ng gi·∫£m 50%
        effective_price = base_price * 0.5
        
        # D·ª± ƒëo√°n s·ªë l∆∞·ª£ng b√°n
        effective_price_poly = poly_features.transform(np.array([[effective_price]]))
        effective_qty = max(0, poly_model.predict(effective_price_poly)[0]) * 2  # Nh√¢n 2 v√¨ m·ªói ƒë∆°n h√†ng l√† 2 s·∫£n ph·∫©m
        
        # T√≠nh doanh thu v√† l·ª£i nhu·∫≠n
        effective_revenue = base_price * effective_qty / 2  # Doanh thu ch·ªâ t√≠nh tr√™n s·∫£n ph·∫©m ƒë∆∞·ª£c b√°n
        effective_cost = cost_price * effective_qty  # Chi ph√≠ t√≠nh tr√™n t·∫•t c·∫£ s·∫£n ph·∫©m (c·∫£ t·∫∑ng)
        effective_profit = effective_revenue - effective_cost
        
        # So s√°nh v·ªõi kh√¥ng khuy·∫øn m√£i
        current_revenue = base_price * current_qty
        current_cost = cost_price * current_qty
        current_profit = current_revenue - current_cost
        
        revenue_change = ((effective_revenue - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        profit_change = ((effective_profit - current_profit) / current_profit * 100) if current_profit > 0 else 0
        
        # Hi·ªÉn th·ªã k·∫øt qu·∫£
        col1, col2 = st.columns(2)
        with col1:
            st.metric("S·ªë l∆∞·ª£ng s·∫£n ph·∫©m d·ª± ƒëo√°n", f"{effective_qty:.2f}", f"+{((effective_qty - current_qty) / current_qty * 100):.2f}%")
            st.metric("Doanh thu d·ª± ƒëo√°n", f"{effective_revenue:.2f}", f"{revenue_change:.2f}%")
        with col2:
            st.metric("Chi ph√≠ d·ª± ƒëo√°n", f"{effective_cost:.2f}", f"+{((effective_cost - current_cost) / current_cost * 100):.2f}%")
            st.metric("L·ª£i nhu·∫≠n d·ª± ƒëo√°n", f"{effective_profit:.2f}", f"{profit_change:.2f}%")
        
        # ƒê·ªÅ xu·∫•t
        st.subheader("ƒê√°nh gi√° ch∆∞∆°ng tr√¨nh")
        if profit_change > 0:
            st.success(f"‚úÖ Ch∆∞∆°ng tr√¨nh Mua 1 t·∫∑ng 1 d·ª± ki·∫øn l√†m tƒÉng l·ª£i nhu·∫≠n {profit_change:.2f}%. N√™n √°p d·ª•ng.")
        else:
            st.error(f"‚ùå Ch∆∞∆°ng tr√¨nh Mua 1 t·∫∑ng 1 d·ª± ki·∫øn l√†m gi·∫£m l·ª£i nhu·∫≠n {abs(profit_change):.2f}%. Kh√¥ng n√™n √°p d·ª•ng.")
    
    elif promo_type == "Combo gi·∫£m gi√°":
        st.subheader("Ph√¢n t√≠ch ch∆∞∆°ng tr√¨nh Combo gi·∫£m gi√°")
        
        # Cho ph√©p ng∆∞·ªùi d√πng ch·ªçn s·∫£n ph·∫©m th·ª© 2 ƒë·ªÉ combo
        second_product = st.selectbox("Ch·ªçn s·∫£n ph·∫©m th·ª© 2 cho combo", items)
        combo_discount = st.slider("Gi·∫£m gi√° cho combo (%)", 5, 30, 15, 5)
        
        # T√≠nh to√°n
        second_price = merged[merged['ITEM_NAME'] == second_product]['PRICE'].mean()
        total_price = base_price + second_price
        combo_price = total_price * (1 - combo_discount / 100)
        
        st.write(f"Gi√° g·ªëc c·ªßa hai s·∫£n ph·∫©m: {total_price:.2f}")
        st.write(f"Gi√° combo sau gi·∫£m: {combo_price:.2f} (Ti·∫øt ki·ªám: {total_price - combo_price:.2f})")
        
        # D·ª± ƒëo√°n s·ªë l∆∞·ª£ng combo b√°n ƒë∆∞·ª£c
        equivalent_single_price = combo_price / 2  # Gi·∫£ ƒë·ªãnh gi√° b√¨nh qu√¢n m·ªói s·∫£n ph·∫©m trong combo
        equivalent_price_poly = poly_features.transform(np.array([[equivalent_single_price]]))
        estimated_combo_qty = max(0, poly_model.predict(equivalent_price_poly)[0]) * 0.5  # Gi·∫£ ƒë·ªãnh 50% kh√°ch h√†ng s·∫Ω mua combo
        
        # Hi·ªÉn th·ªã d·ª± ƒëo√°n
        st.metric("S·ªë l∆∞·ª£ng combo d·ª± ƒëo√°n", f"{estimated_combo_qty:.2f}")
        st.metric("Doanh thu t·ª´ combo", f"{combo_price * estimated_combo_qty:.2f}")

        # Gi·∫£ ƒë·ªãnh chi ph√≠ v√† t√≠nh l·ª£i nhu·∫≠n
        cost_pct = st.slider(
            "Chi ph√≠ (% gi√° b√°n)", 30, 70, 50, 5, 
            help="Chi ph√≠ s·∫£n xu·∫•t/nh·∫≠p h√†ng t√≠nh theo % gi√° b√°n",
            key="cost_pct_combo_discount"
        )
        cost_price_first = base_price * (cost_pct / 100)
        cost_price_second = second_price * (cost_pct / 100)
        total_cost_per_combo = cost_price_first + cost_price_second
        combo_profit = (combo_price - total_cost_per_combo) * estimated_combo_qty

        # So s√°nh v·ªõi kh√¥ng khuy·∫øn m√£i
        current_qty = df_clean['QUANTITY'].mean()
        current_revenue = base_price * current_qty
        current_cost = cost_price_first * current_qty
        current_profit = current_revenue - current_cost

        revenue_change = ((combo_price * estimated_combo_qty - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        profit_change = ((combo_profit - current_profit) / current_profit * 100) if current_profit > 0 else 0

        # Hi·ªÉn th·ªã k·∫øt qu·∫£
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Doanh thu combo d·ª± ƒëo√°n", f"{combo_price * estimated_combo_qty:.2f}", f"{revenue_change:.2f}%")
        with col2:
            st.metric("L·ª£i nhu·∫≠n combo d·ª± ƒëo√°n", f"{combo_profit:.2f}", f"{profit_change:.2f}%")

        # ƒê·ªÅ xu·∫•t
        st.subheader("ƒê√°nh gi√° ch∆∞∆°ng tr√¨nh Combo gi·∫£m gi√°")
        if profit_change > 0:
            st.success(f"‚úÖ Ch∆∞∆°ng tr√¨nh combo gi·∫£m gi√° {combo_discount}% d·ª± ki·∫øn tƒÉng l·ª£i nhu·∫≠n {profit_change:.2f}%. N√™n √°p d·ª•ng.")
        else:
            st.warning(f"‚ö†Ô∏è Ch∆∞∆°ng tr√¨nh combo gi·∫£m gi√° {combo_discount}% d·ª± ki·∫øn gi·∫£m l·ª£i nhu·∫≠n {abs(profit_change):.2f}%. C·∫ßn c√¢n nh·∫Øc th√™m.")

    elif promo_type == "Gi·∫£m gi√° theo s·ªë l∆∞·ª£ng":
        st.subheader("Ph√¢n t√≠ch ch∆∞∆°ng tr√¨nh Gi·∫£m gi√° theo s·ªë l∆∞·ª£ng")

        # Ng∆∞·ªùi d√πng ch·ªçn s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu v√† m·ª©c gi·∫£m gi√°
        min_qty = st.number_input("S·ªë l∆∞·ª£ng t·ªëi thi·ªÉu ƒë·ªÉ √°p d·ª•ng gi·∫£m gi√°", min_value=2, value=3, step=1)
        qty_discount_pct = st.slider("M·ª©c gi·∫£m gi√° khi mua t·ª´ s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu (%)", 5, 30, 10, 5)

        # Ng∆∞·ªùi d√πng nh·∫≠p chi ph√≠ (% gi√° b√°n)
        cost_pct = st.slider(
            "Chi ph√≠ (% gi√° b√°n)", 
            30, 70, 50, 5, 
            help="Chi ph√≠ s·∫£n xu·∫•t/nh·∫≠p h√†ng t√≠nh theo % gi√° b√°n",
            key="cost_pct_quantity_discount"
        )

        # T√≠nh gi√° sau gi·∫£m
        discounted_price = base_price * (1 - qty_discount_pct / 100)

        # D·ª± ƒëo√°n s·ªë l∆∞·ª£ng b√°n v·ªõi gi√° gi·∫£m
        discounted_price_poly = poly_features.transform(np.array([[discounted_price]]))
        discounted_qty = max(0, poly_model.predict(discounted_price_poly)[0])

        # Gi·∫£ ƒë·ªãnh m·ªôt ph·∫ßn kh√°ch h√†ng s·∫Ω mua s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu
        estimated_qty = discounted_qty * (min_qty / 2)  # Gi·∫£ ƒë·ªãnh trung b√¨nh mua g·∫•p ƒë√¥i s·ªë l∆∞·ª£ng t·ªëi thi·ªÉu
        revenue_qty_discount = discounted_price * estimated_qty
        cost_price = base_price * (cost_pct / 100)
        profit_qty_discount = (discounted_price - cost_price) * estimated_qty

        # So s√°nh v·ªõi kh√¥ng khuy·∫øn m√£i
        current_qty = df_clean['QUANTITY'].mean()
        current_revenue = base_price * current_qty
        current_cost = cost_price * current_qty
        current_profit = current_revenue - current_cost

        revenue_change = ((revenue_qty_discount - current_revenue) / current_revenue * 100) if current_revenue > 0 else 0
        profit_change = ((profit_qty_discount - current_profit) / current_profit * 100) if current_profit > 0 else 0

        # Hi·ªÉn th·ªã k·∫øt qu·∫£
        col1, col2 = st.columns(2)
        with col1:
            st.metric("S·ªë l∆∞·ª£ng d·ª± ƒëo√°n", f"{estimated_qty:.2f}")
            st.metric("Doanh thu d·ª± ƒëo√°n", f"{revenue_qty_discount:.2f}", f"{revenue_change:.2f}%")
        with col2:
            st.metric("L·ª£i nhu·∫≠n d·ª± ƒëo√°n", f"{profit_qty_discount:.2f}", f"{profit_change:.2f}%")

        # ƒê·ªÅ xu·∫•t
        st.subheader("ƒê√°nh gi√° ch∆∞∆°ng tr√¨nh Gi·∫£m gi√° theo s·ªë l∆∞·ª£ng")
        if profit_change > 0:
            st.success(f"‚úÖ Ch∆∞∆°ng tr√¨nh gi·∫£m gi√° {qty_discount_pct}% khi mua t·ª´ {min_qty} s·∫£n ph·∫©m d·ª± ki·∫øn tƒÉng l·ª£i nhu·∫≠n {profit_change:.2f}%. N√™n √°p d·ª•ng.")
        else:
            st.warning(f"‚ö†Ô∏è Ch∆∞∆°ng tr√¨nh gi·∫£m gi√° {qty_discount_pct}% khi mua t·ª´ {min_qty} s·∫£n ph·∫©m d·ª± ki·∫øn gi·∫£m l·ª£i nhu·∫≠n {abs(profit_change):.2f}%. C·∫ßn c√¢n nh·∫Øc th√™m.")

# Tab 10: ƒê·ªÅ xu·∫•t s·∫£n ph·∫©m c·∫ßn ƒëi·ªÅu ch·ªânh gi√°
with tabs[9]:
    st.header("üì¶ ƒê·ªÅ xu·∫•t s·∫£n ph·∫©m c·∫ßn ƒëi·ªÅu ch·ªânh gi√°")

    # Ph√¢n t√≠ch t·∫•t c·∫£ s·∫£n ph·∫©m
    product_analysis = merged.groupby('ITEM_NAME').agg({
        'PRICE': 'mean',
        'QUANTITY': 'mean',
        'CALENDAR_DATE': 'count'
    }).reset_index()
    product_analysis['Revenue'] = product_analysis['PRICE'] * product_analysis['QUANTITY']
    product_analysis = product_analysis.rename(columns={'CALENDAR_DATE': 'S·ªë giao d·ªãch'})

    # T√≠nh ƒë·ªô co gi√£n c·ªßa c·∫ßu cho t·ª´ng s·∫£n ph·∫©m (n·∫øu c√≥ ƒë·ªß d·ªØ li·ªáu)
    elasticity_dict = {}
    for item in product_analysis['ITEM_NAME']:
        df_item = merged[merged['ITEM_NAME'] == item].groupby('PRICE')['QUANTITY'].sum().reset_index()
        if len(df_item) > 1:  # C·∫ßn √≠t nh·∫•t 2 m·ª©c gi√° ƒë·ªÉ t√≠nh elasticity
            X_item = df_item[['PRICE']].values
            y_item = df_item['QUANTITY'].values
            model_item = LinearRegression().fit(X_item, y_item)
            avg_price_item = df_item['PRICE'].mean()
            avg_qty_item = df_item['QUANTITY'].mean()
            elasticity_dict[item] = abs(model_item.coef_[0] * (avg_price_item / avg_qty_item)) if avg_qty_item > 0 else 0
        else:
            elasticity_dict[item] = None

    product_analysis['Elasticity'] = product_analysis['ITEM_NAME'].map(elasticity_dict)

    # X√°c ƒë·ªãnh s·∫£n ph·∫©m c·∫ßn ƒëi·ªÅu ch·ªânh gi√°
    low_revenue_threshold = product_analysis['Revenue'].quantile(0.25)
    high_elasticity_threshold = product_analysis['Elasticity'].quantile(0.75, interpolation='nearest') if product_analysis['Elasticity'].notna().sum() > 0 else 1

    product_analysis['ƒê·ªÅ xu·∫•t'] = product_analysis.apply(
        lambda row: 'Gi·∫£m gi√°' if (row['Revenue'] < low_revenue_threshold and row['Elasticity'] is not None and row['Elasticity'] > high_elasticity_threshold)
        else 'TƒÉng gi√°' if (row['Revenue'] < low_revenue_threshold and row['Elasticity'] is not None and row['Elasticity'] < 1)
        else 'Gi·ªØ nguy√™n', axis=1
    )

    # Hi·ªÉn th·ªã b·∫£ng k·∫øt qu·∫£
    st.subheader("Ph√¢n t√≠ch v√† ƒë·ªÅ xu·∫•t ƒëi·ªÅu ch·ªânh gi√° s·∫£n ph·∫©m")
    st.dataframe(product_analysis)

    # L·ªçc c√°c s·∫£n ph·∫©m c·∫ßn ƒëi·ªÅu ch·ªânh
    adjustment_needed = product_analysis[product_analysis['ƒê·ªÅ xu·∫•t'] != 'Gi·ªØ nguy√™n']
    if not adjustment_needed.empty:
        st.subheader("S·∫£n ph·∫©m c·∫ßn ƒëi·ªÅu ch·ªânh gi√°")
        st.dataframe(adjustment_needed)
    else:
        st.info("‚ÑπÔ∏è Kh√¥ng c√≥ s·∫£n ph·∫©m n√†o c·∫ßn ƒëi·ªÅu ch·ªânh gi√° d·ª±a tr√™n d·ªØ li·ªáu hi·ªán t·∫°i.")

# Tab 11: ƒê·ªãnh gi√° c√° nh√¢n h√≥a (ƒëang ph√°t tri·ªÉn)
with tabs[10]:
    st.header("üë§ ƒê·ªãnh gi√° c√° nh√¢n h√≥a (ƒêang ph√°t tri·ªÉn)")

    st.info("T√≠nh nƒÉng n√†y ƒëang trong qu√° tr√¨nh ph√°t tri·ªÉn. √ù t∆∞·ªüng bao g·ªìm:")
    st.markdown("""
    - S·ª≠ d·ª•ng d·ªØ li·ªáu kh√°ch h√†ng (n·∫øu c√≥) ƒë·ªÉ ph√¢n kh√∫c kh√°ch h√†ng theo h√†nh vi mua s·∫Øm.
    - ƒê·ªÅ xu·∫•t gi√° kh√°c nhau cho t·ª´ng nh√≥m kh√°ch h√†ng d·ª±a tr√™n ƒë·ªô nh·∫°y c·∫£m gi√°.
    - T√≠ch h·ª£p m√¥ h√¨nh h·ªçc m√°y ƒë·ªÉ d·ª± ƒëo√°n m·ª©c gi√° t·ªëi ∆∞u cho t·ª´ng kh√°ch h√†ng.
    """)

    # Possible column names for customer ID
    possible_customer_cols = ['CUSTOMER_ID', 'CustomerID', 'customer_id', 'UserID', 'ClientID', 'user_id']
    customer_col = None
    for col in possible_customer_cols:
        if col in merged.columns:
            customer_col = col
            break

    if customer_col:
        customer_analysis = merged.groupby(customer_col).agg({
            'PRICE': 'mean',
            'QUANTITY': 'sum',
            'CALENDAR_DATE': 'count'
        }).reset_index()
        customer_analysis['Revenue'] = customer_analysis['PRICE'] * customer_analysis['QUANTITY']
        st.subheader(f"Ph√¢n t√≠ch s∆° b·ªô theo kh√°ch h√†ng (s·ª≠ d·ª•ng c·ªôt: {customer_col})")
        st.dataframe(customer_analysis.head())
    else:
        st.warning("Kh√¥ng t√¨m th·∫•y c·ªôt d·ªØ li·ªáu kh√°ch h√†ng (ki·ªÉm tra c√°c c·ªôt: {}).".format(', '.join(possible_customer_cols)))
        st.write("C√°c c·ªôt hi·ªán c√≥ trong d·ªØ li·ªáu merged:", merged.columns.tolist())
        st.info("ƒê·ªÉ k√≠ch ho·∫°t t√≠nh nƒÉng n√†y, h√£y th√™m m·ªôt c·ªôt nh∆∞ 'CUSTOMER_ID' v√†o file transaction.csv.")

# K·∫øt th√∫c ·ª©ng d·ª•ng
st.sidebar.success("Ph√¢n t√≠ch ho√†n t·∫•t! Ch·ªçn tab ƒë·ªÉ xem k·∫øt qu·∫£.")